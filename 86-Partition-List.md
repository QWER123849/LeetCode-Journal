这是一篇针对 LeetCode 86 题（分隔链表）的详细教学文章，基于你提供的代码进行了解析。文章风格专注于解题思路和代码逻辑，力求清晰易懂。

---

# 【LeetCode 86】分隔链表：双虚拟头节点法的完美应用

在链表题目中，调整节点顺序而不改变其相对位置，是一类非常考察逻辑严密性的题目。LeetCode 第 86 题“分隔链表”就是这样一道经典题目。

## 1. 题目回顾
给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

**核心要求**：你应当保留两个分区中每个节点的**初始相对位置**。

**示例**：
> 输入：`head = [1,4,3,2,5,2], x = 3`
> 输出：`[1,2,2,4,3,5]`
> (小于3的 `1,2,2` 在前，大于等于3的 `4,3,5` 在后，且各自的内部顺序不变)

## 2. 解题思路：双链表合并法

如果我们在原链表上进行交换操作，维护指针的指向会非常复杂。最直观且不易出错的方法是**将原链表拆分成两个新链表**：

1.  **小链表 (Small List)**：专门存放值小于 `x` 的节点。
2.  **大链表 (Large List)**：专门存放值大于或等于 `x` 的节点。

我们遍历原链表，把节点分配到对应的链表中，最后将“小链表”的尾部连接到“大链表”的头部，即可完成任务。

为了处理方便，我们引入**虚拟头节点 (Dummy Node)**。这可以避免处理头节点为空的边界情况，让代码逻辑更加统一。

## 3. 代码与逻辑详解

下面是基于 C++ 的标准解法，使用了双指针策略。

### 3.1 初始化

首先，我们需要两个虚拟头节点和两个游标指针。

```cpp
ListNode* partition(ListNode* head, int x) {
    // dummy1 用于挂接所有 < x 的节点
    ListNode* dummy1 = new ListNode(-1);
    // dummy2 用于挂接所有 >= x 的节点
    ListNode* dummy2 = new ListNode(-1);
    
    // p1 和 p2 分别作为两个链表的当前尾指针
    ListNode* p1 = dummy1;
    ListNode* p2 = dummy2;
    
    // p 用于遍历原链表
    ListNode* p = head;
```

### 3.2 遍历与拆分（核心技巧）

这是解题中最关键的一步。在遍历过程中，我们需要将当前节点 `p` 从原链表中“摘下来”，然后接到 `p1` 或 `p2` 后面。

**⚠️ 避坑指南：断链操作**
在很多链表题中，最容易出现的错误就是**成环**。如果直接把节点接到新链表而不打断它原本的 `next` 指针，原来的连接关系可能会导致死循环。

在这份代码中，采用了**“处理即断开”**的策略，非常安全：

```cpp
    while(p != nullptr){
        if(p->val < x){
            p1->next = p;       // 1. 接到小链表后
            p1 = p1->next;      // 2. 指针后移
        }else{
            p2->next = p;       // 1. 接到大链表后
            p2 = p2->next;      // 2. 指针后移
        }
        
        // --- 核心断链逻辑 ---
        ListNode* temp = p->next; // 1. 先保存原链表的下一个节点
        p->next = nullptr;        // 2. 彻底切断当前节点与原链表的联系（防止成环）
        p = temp;                 // 3. 继续处理下一个节点
    }
```

**为什么这段代码写得好？**
很多解法是在遍历结束后再去手动切断 `p2` 的尾部，容易遗忘导致报错。而上面的写法在循环内部，每处理一个节点，就将其 `next` 设为 `nullptr`。这意味着进入 `p1` 或 `p2` 链表的每一个节点都是干净、独立的，彻底杜绝了环的产生。

### 3.3 拼接与返回

遍历结束后，我们拥有了两个有序的链表：
*   `dummy1` 链表：所有小于 `x` 的节点。
*   `dummy2` 链表：所有大于等于 `x` 的节点。

最后一步就是把它们连起来。

```cpp
    // 将小链表的尾部（p1）指向大链表的第一个真实节点（dummy2->next）
    p1->next = dummy2->next;
    
    // 返回小链表的虚拟头节点的下一位，即整条链表的头
    return dummy1->next;
}
```

## 4. 复杂度分析

*   **时间复杂度**: $O(N)$
    我们需要遍历原链表一次，每个节点的操作都是常数级时间，所以是线性的。
*   **空间复杂度**: $O(1)$
    我们只使用了几个指针变量（`dummy1`, `dummy2`, `p1`, `p2`, `temp`），直接复用了原链表的节点内存，没有开辟额外的数组或链表空间（除了两个 dummy 节点），所以空间复杂度是常数级。

## 5. 总结

这道题是链表操作的模板级题目，它教会了我们两个重要的技巧：
1.  **双虚拟头节点**：将复杂的链表重排问题，转化为简单的“拆分+合并”问题。
2.  **断链意识**：在重组链表节点时，时刻注意切断旧的 `next` 指针，防止隐蔽的环形链表导致程序崩溃。

只要掌握了这两点，解决大多数链表调整顺序的题目都会游刃有余。
